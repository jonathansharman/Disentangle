import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha2;

const X_RES = 640;
const Y_RES = 480;

const NODE_RADIUS = 10.0;
const NODE_BORDER = 2.0;

const EDGE_WIDTH = 3.5;

const BAR_HEIGHT = 20;

const MAX_TIME_PER_EDGE = 100;
const MAX_MOVES_PER_EDGE = 1;

const WIN_TIMER_LENGTH = 75;

const COLOR_SATURATION = 0.6;
const COLOR_VALUE = 0.9;

// Helps avoid false positives at endpoints.
const COLLISION_EPSILON = 0.01;

enum GameMode { RELAX, TIMED, MOVES }

class MainScene : AbstractScene {
	field clickedNode;
	field nodeCount;
	field nodes = [];
	field edges = [];
	field solved = false;
	field intersectMap;
	field winTimer = 0;
	field font = FontResource.fromSystem("Times New Roman").getRenderer().setSize(20);
	field levelText;
	field resetText = this.font.setColor(0, 0, 0).render("Press Esc to return to main menu.");

	field gameMode;

	field maxLevelTime;
	field levelTimer;

	field maxMoves;
	field movesLeft;

	field gameOver = false;

	field loaded = false;
	field loadNextFrame = false;
	field loadingText = this.font.setColor(128, 128, 128).render("Loading...");

	field nodeDrawOrder;
	field nodeColors;
	field edgeDrawOrder;
	field edgeColors;

	constructor(gameMode, nodeCount) : base() {
		this.gameMode = gameMode;
		this.nodeCount = nodeCount;
		this.levelText = this.font.setColor(0, 0, 0).render(this.nodeCount);
	}

	// Computes x mod y, where x and y are nonnegative floating-point numbers.
	static function fmod(x, y) {
		while (x > y) {
			x -= y;
		}
		return x;
	}

	// h in [0.0, 360.0)
	// s in [0.0, 1.0]
	// v in [0.0, 1.0]
	static function hsvToRgb(h, s, v) {
		c = v * s;
		x = c * (1.0 - Math.abs(MainScene.fmod(h / 60, 2.0) - 1.0));
		m = v - c;
		switch (floor(h) / 60) {
			case 0:
				rgbPrime = [c, x, 0];
				break;
			case 1:
				rgbPrime = [x, c, 0];
				break;
			case 2:
				rgbPrime = [0, c, x];
				break;
			case 3:
				rgbPrime = [0, x, c];
				break;
			case 4:
				rgbPrime = [x, 0, c];
				break;
			case 5:
				rgbPrime = [c, 0, x];
				break;
		}
		return
			[ Math.floor((rgbPrime[0] + m) * 255)
			, Math.floor((rgbPrime[1] + m) * 255)
			, Math.floor((rgbPrime[2] + m) * 255)
			];
	}

	// Checks for intersection between line segments.
	// Adapted from https://stackoverflow.com/a/1968345/3217185.
	function intersect(edge0, edge1) {
		if (this.nodes[edge0[0]][0] <= this.nodes[edge0[1]][0]) {
			p0_x = this.nodes[edge0[0]][0];
			p0_y = this.nodes[edge0[0]][1];
			p1_x = this.nodes[edge0[1]][0];
			p1_y = this.nodes[edge0[1]][1];
		} else {
			p0_x = this.nodes[edge0[1]][0];
			p0_y = this.nodes[edge0[1]][1];
			p1_x = this.nodes[edge0[0]][0];
			p1_y = this.nodes[edge0[0]][1];
		}
		// p0 is the left-most node of edge0.
		if (this.nodes[edge1[0]][0] <= this.nodes[edge1[1]][0]) {
			p2_x = this.nodes[edge1[0]][0];
			p2_y = this.nodes[edge1[0]][1];
			p3_x = this.nodes[edge1[1]][0];
			p3_y = this.nodes[edge1[1]][1];
		} else {
			p2_x = this.nodes[edge1[1]][0];
			p2_y = this.nodes[edge1[1]][1];
			p3_x = this.nodes[edge1[0]][0];
			p3_y = this.nodes[edge1[0]][1];
		}
		// p2 is the left-most node of edge1.

		// Rule out intersection if one edge is completely to one side of the other.
		if (p1_x < p2_x) {
			// edge0 left of edge1.
			return false;
		}
		if (p0_x > p3_x) {
			// edge0 right of edge1.
			return false;
		}
		if (Math.max(p0_y, p1_y) < Math.min(p2_y, p3_y)) {
			// edge0 above edge1.
			return false;
		}
		if (Math.min(p0_y, p1_y) > Math.max(p2_y, p3_y)) {
			// edge0 below edge1.
			return false;
		}

	    s1_x = p1_x - p0_x;
		s1_y = p1_y - p0_y;
		s2_x = p3_x - p2_x;
		s2_y = p3_y - p2_y;

		denominator = -s2_x * s1_y + s1_x * s2_y;
		if (denominator == 0.0) {
			// Parallel. Could be collinear (ignoring this case).
			return false;
		}
		
		s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denominator;
		t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denominator;

		return s >= COLLISION_EPSILON && s <= (1.0 - COLLISION_EPSILON)
			&& t >= COLLISION_EPSILON && t <= (1 - COLLISION_EPSILON);
	}

	// Randomize node positions.
	function randomizeNodes() {
		for (i = 0; i < this.nodeCount; ++i) {
			this.nodes[i][0] = (0.1 + 0.8 * Random.randomFloat()) * X_RES;
			this.nodes[i][1] = (0.1 + 0.8 * Random.randomFloat()) * Y_RES;
		}
	}

	// Reset the game.
	function reset() {
		this.clickedNode = null;

		// Initialize nodes in a circle.
		this.nodes = [];
		for (i = 0; i < this.nodeCount; ++i) {
			theta = i * 2 * Math.PI / this.nodeCount;
			offset = Math.min(X_RES, Y_RES) / 2 - 20;
			this.nodes.add([X_RES / 2 + offset * Math.cos(theta), Y_RES / 2 + offset * Math.sin(theta)]);
		}

		// Generate all possible edges in random order.
		allEdges = [];
		for (i = 0; i < this.nodes.length - 1; ++i) {
			for (j = i + 1; j < this.nodes.length; ++j) {
				allEdges.add([i, j]);
			}
		}
		allEdges.shuffle();

		// Add random non-intersecting edges to the edge list.
		this.edges = [];
		for (candidateEdge : allEdges) {
			foundIntersection = false;
			for (existingEdge : this.edges) {
				if (this.intersect(candidateEdge, existingEdge)) {
					foundIntersection = true;
					break;
				}
			}
			if (!foundIntersection) {
				this.edges.add(candidateEdge);
			}
		}

		// Randomize node positions until there's an intersection.
		foundIntersection = false;
		do {
			this.randomizeNodes();
			for (i = 0; !foundIntersection && i < this.edges.length - 1; ++i) {
				for (j = i + 1; j < this.edges.length; ++j) {
					if (this.intersect(this.edges[i], this.edges[j])) {
						foundIntersection = true;
						break;
					}
				}
			}
		} while (!foundIntersection);

		// Relax nodes using antigravitation.
		this.antigravitate(300);

		this.levelText = this.font.setColor(0, 0, 0).render(this.nodes.length);

		this.maxLevelTime = MAX_TIME_PER_EDGE * this.edges.length;
		this.levelTimer = this.maxLevelTime;

		this.maxMoves = MAX_MOVES_PER_EDGE * this.edges.length;
		this.movesLeft = this.maxMoves;

		// Set draw orders and colors.
		this.nodeDrawOrder = [];
		for (i = 0; i < this.nodes.length; ++i) {
			this.nodeDrawOrder.add(i);
		}
		// Shuffle node draw order (and therefore color assignment) to avoid giving hints.
		this.nodeDrawOrder.shuffle();
		this.nodeColors = [];
		for (i = 0; i < this.nodes.length; ++i) {
			this.nodeColors.add(MainScene.hsvToRgb
				( this.nodeDrawOrder[i] * 360.0 / this.nodes.length
				, COLOR_SATURATION
				, COLOR_VALUE
				));
		}
		// Edges are already shuffled. Assign draw order and colors in order.
		this.edgeDrawOrder = [];
		this.edgeColors = [];
		for (i = 0; i < this.edges.length; ++i) {
			this.edgeDrawOrder.add(i);
			this.edgeColors.add(MainScene.hsvToRgb
				( i * 360.0 / this.nodes.length
				, COLOR_SATURATION
				, COLOR_VALUE
				));
		}
	}

	// Pushes nodes away from each other and away from the edges.
	function antigravitate(iterations) {
		for (i = 0; i < iterations; ++i) {
			for (node : this.nodes) {
				wallForceFactor = 0.0005;
				vel =
					[ wallForceFactor * (X_RES / 2 - node[0])
					, wallForceFactor * (Y_RES / 2 - node[1])
					];
				for (otherNode : this.nodes) {
					if (otherNode != node) {
						dx = node[0] - otherNode[0];
						dy = node[1] - otherNode[1];
						d2 = dx ** 2.0 + dy ** 2.0;
						if (d2 != 0.0) {
							vel[0] += dx / d2;
							vel[1] += dy / d2;
						}
					}
				}
				velFactor = 15.0;
				node[0] += velFactor * vel[0];
				node[1] += velFactor * vel[1];

				if (node[0] < 0.0) {
					node[0] = 0.0;
				} else if (node[0] >= X_RES) {
					node[0] = X_RES - 1.0;
				}
				if (node[1] < 0.0) {
					node[1] = 0.0;
				} else if (node[1] >= Y_RES) {
					node[1] = Y_RES - 1.0;
				}
			}
		}
	}

	// Moves the node with the given index and its attached edges to the front.
	function moveToFront(index) {
		// Bubble up the target node.
		for (i = 0; i < this.nodeDrawOrder.length - 1; ++i) {
			if (this.nodeDrawOrder[i] == index) {
				t = this.nodeDrawOrder[i + 1];
				this.nodeDrawOrder[i] = t;
				this.nodeDrawOrder[i + 1] = index;
			}
		}
		// Stably partition the edges, with attached edges in front.
		edgeDrawOrderPartition = [[], []];
		edgeColorsPartition = [[], []];
		for (i = 0; i < this.edgeDrawOrder.length; ++i) {
			edge = this.edges[this.edgeDrawOrder[i]];
			if (edge[0] == index || edge[1] == index) {
				edgeDrawOrderPartition[1].add(this.edgeDrawOrder[i]);
				edgeColorsPartition[1].add(this.edgeColors[i]);
			} else {
				edgeDrawOrderPartition[0].add(this.edgeDrawOrder[i]);
				edgeColorsPartition[0].add(this.edgeColors[i]);
			}
		}
		this.edgeDrawOrder = edgeDrawOrderPartition[0];
		this.edgeDrawOrder.concat(edgeDrawOrderPartition[1]);
		this.edgeColors = edgeColorsPartition[0];
		this.edgeColors.concat(edgeColorsPartition[1]);
	}

	function update(inputManager, events) {
		if (this.loadNextFrame) {
			this.reset();
			this.loaded = true;
			this.loadNextFrame = false;
		} else if (!this.loaded) {
			this.loadNextFrame = true;
			return;
		}

		if (inputManager.isKeyPressed(KeyboardKey.ESCAPE)) {
			this.switchScene(new TitleScene());
			return;
		}

		if (this.winTimer == 0) {
			--this.levelTimer;
		}

		if (this.winTimer > 0) {
			if (this.winTimer == 1) {
				++this.nodeCount;
				this.loaded = false;
				this.loadNextFrame = false;
			}
			--this.winTimer;
			return;
		}

		mousePos = inputManager.getMousePosition();
		xMouse = 1.0 * mousePos[0];
		yMouse = 1.0 * mousePos[1];

		for (e : events) {
			switch (e.type) {
				case EventType.MOUSE_RELEASE:
					// Release clicked node, if any.
					if (this.clickedNode != null) {
						--this.movesLeft;
						this.clickedNode = null;
						if (this.solved && this.winTimer == 0) {
							this.winTimer = WIN_TIMER_LENGTH;
						}
					}
					break;
				case EventType.MOUSE_PRESS:
					// Find clicked node, if any.
					minDistance = 2 * NODE_RADIUS;
					for (i = 0; i < this.nodes.length; ++i) {
						distance = ((this.nodes[i][0] - xMouse) ** 2 + (this.nodes[i][1] - yMouse) ** 2) ** 0.5;
						if (distance <= NODE_RADIUS && (distance < minDistance)) {
							this.clickedNode = i;
							minDistance = distance;
						}
					}
					if (this.clickedNode != null) {
						// Move clicked node and attached edges to the front.
						this.moveToFront(this.clickedNode);
					}
					break;
				default:
					break;
			}
		}

		// Allow free manual antigravitation if game is not over.
		if (!this.gameOver && this.winTimer == 0 && inputManager.isKeyPressed(KeyboardKey.SPACE)) {
			this.antigravitate(1);
		}

		// Clicked node follows mouse.
		if (this.clickedNode != null && !this.gameOver) {
			this.nodes[this.clickedNode][0] = xMouse;
			this.nodes[this.clickedNode][1] = yMouse;
		}

		// Find intersections and detect solutions.
		this.solved = true;
		this.intersectMap = [];
		for (i = 0; i < this.edges.length; ++i) {
			foundIntersection = false;
			for (otherEdge : this.edges) {
				if (otherEdge != this.edges[i] && this.intersect(this.edges[i], otherEdge)) {
					foundIntersection = true;
					this.solved = false;
					break;
				}
			}
			this.intersectMap.add(foundIntersection);
		}

		// Check for game over.
		switch (this.gameMode) {
			case GameMode.RELAX:
				break;
			case GameMode.TIMED:
				if (!this.solved && this.levelTimer == 0) {
					this.gameOver = true;
				}
				break;
			case GameMode.MOVES:
				if (!this.solved && this.movesLeft == 0) {
					this.gameOver = true;
				}
				break;
		}
	}

	function render() {
		bgColor = this.gameOver ? [212, 159, 159] : [212, 212, 212];

		Graphics2D.Draw.fill(bgColor[0], bgColor[1], bgColor[2]);

		if (!this.loaded) {
			this.loadingText.draw
				( X_RES / 2 - this.loadingText.width / 2
				, Y_RES / 2 - this.loadingText.height / 2
				);
		} else {
			// Draw edges.
			for (i = 0; i < this.edgeDrawOrder.length; ++i) {
				j = this.edgeDrawOrder[i];
				alpha = this.solved && this.winTimer > 0
					? 64 * this.winTimer / WIN_TIMER_LENGTH
					: this.intersectMap[j] ? 255 : 64;
				// Draw edge outline.
				Graphics2D.Draw.line
					( this.nodes[this.edges[j][0]][0], this.nodes[this.edges[j][0]][1]
					, this.nodes[this.edges[j][1]][0], this.nodes[this.edges[j][1]][1]
					, EDGE_WIDTH + 2
					, 0, 0, 0, alpha
					);
				// Draw edge fill.
				edgeColor = this.edgeColors[i];
				Graphics2D.Draw.line
					( this.nodes[this.edges[j][0]][0], this.nodes[this.edges[j][0]][1]
					, this.nodes[this.edges[j][1]][0], this.nodes[this.edges[j][1]][1]
					, EDGE_WIDTH
					, edgeColor[0], edgeColor[1], edgeColor[2], alpha
					);
			}

			// Draw nodes.
			for (i = 0; i < this.nodeDrawOrder.length; ++i) {
				j = this.nodeDrawOrder[i];
				nodeColor = MainScene.hsvToRgb(j * 360.0 / this.nodes.length, COLOR_SATURATION, COLOR_VALUE);
				nodeColor = this.nodeColors[j];
				if (this.solved && this.winTimer > 0) {
					alpha = 64 * this.winTimer / WIN_TIMER_LENGTH;
				} else {
					badNode = false;
					for (k = 0; k < this.edges.length; ++k) {
						if (this.edges[k][0] == j || this.edges[k][1] == j) {
							badNode = badNode || this.intersectMap[k];
						}
					}
					alpha = badNode ? 255 : 64;
				}
				// Draw node outline.
				Graphics2D.Draw.ellipse
					( this.nodes[j][0] - NODE_RADIUS, this.nodes[j][1] - NODE_RADIUS
					, 2 * NODE_RADIUS, 2 * NODE_RADIUS
					, 0, 0, 0, alpha
					);
				// Draw node fill.
				Graphics2D.Draw.ellipse
					( this.nodes[j][0] - NODE_RADIUS + NODE_BORDER, this.nodes[j][1] - NODE_RADIUS + NODE_BORDER
					, 2 * NODE_RADIUS - 2 * NODE_BORDER, 2 * NODE_RADIUS - 2 * NODE_BORDER
					, nodeColor[0], nodeColor[1], nodeColor[2], alpha
					);
			}
		}

		// Draw overlays.
		if (this.gameOver) {
			Graphics2D.Draw.rectangle
				( 0, 0
				, this.resetText.width, this.resetText.height
				, bgColor[0], bgColor[1], bgColor[2], 192
				);
			this.resetText.draw(0, 0);
		} else {
			switch (this.gameMode) {
				case GameMode.RELAX:
					// Nothing special to draw in this mode.
					break;
				case GameMode.TIMED:
					// Draw timer.
					if (this.levelTimer != null) {
						Graphics2D.Draw.rectangle
							( 0, 0
							, X_RES * this.levelTimer / this.maxLevelTime, BAR_HEIGHT
							, 0, 0, 0, 64
							);
					}
					break;
				case GameMode.MOVES:
					// Draw move counter.
					if (this.movesLeft != null) {
						for (i = 0; i < this.movesLeft; ++i) {
							start = i * X_RES / this.maxMoves + 1;
							end = Math.min(X_RES - 1, (i + 1) * X_RES / this.maxMoves);
							Graphics2D.Draw.rectangle
								( start, 1
								, end - start, BAR_HEIGHT - 1
								, 0, 0, 0, 64
								);
						}
					}
					break;
			}
		}

		// Draw current number of nodes.
		Graphics2D.Draw.rectangle
			( 0, Y_RES - this.levelText.height
			, this.levelText.width, this.levelText.height
			, bgColor[0], bgColor[1], bgColor[2], 192
			);
		this.levelText.draw(0, Y_RES - this.levelText.height);
	}
}
