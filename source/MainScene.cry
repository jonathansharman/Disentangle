import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha2;

const X_RES = 640;
const Y_RES = 480;

const NODE_RADIUS = 10.0;
const NODE_BORDER = 2.0;

const EDGE_WIDTH = 3.5;

const BAR_HEIGHT = 20;

const BAD_EDGE_R = 170;
const BAD_EDGE_G = 0;
const BAD_EDGE_B = 0;

const GOOD_EDGE_R = 0;
const GOOD_EDGE_G = 80;
const GOOD_EDGE_B = 160;

const BAD_NODE_R = 212;
const BAD_NODE_G = 0;
const BAD_NODE_B = 0;

const GOOD_NODE_R = 0;
const GOOD_NODE_G = 128;
const GOOD_NODE_B = 255;

const FLASH_NODE_R = 128;
const FLASH_NODE_G = 192;
const FLASH_NODE_B = 255;

const MAX_TIME_PER_EDGE = 100;

const DFLT_NODE_COUNT = 8;

// Helps avoid false positives at endpoints.
const COLLISION_EPSILON = 0.01;

enum GameMode { RELAX, TIMED, MOVES }

class MainScene : AbstractScene {
	field clickedNode;
	field nodeCount = DFLT_NODE_COUNT;
	field nodes;
	field edges;
	field solved = false;
	field intersectMap;
	field winTimer = 0;
	field font = FontResource.fromSystem("Times New Roman").getRenderer().setSize(20).setColor(0, 0, 0);
	field levelText;
	field resetText = this.font.render("Press Esc to return to main menu.");

	field gameMode;

	field levelTimer;

	field movesLeft;

	field gameOver = false;

	constructor(gameMode) : base() {
		this.gameMode = gameMode;

		this.reset();
	}

	// Checks for intersection between line segments.
	// Adapted from https://stackoverflow.com/a/1968345/3217185.
	function intersect(edge0, edge1) {
		if (this.nodes[edge0[0]][0] <= this.nodes[edge0[1]][0]) {
			p0_x = this.nodes[edge0[0]][0];
			p0_y = this.nodes[edge0[0]][1];
			p1_x = this.nodes[edge0[1]][0];
			p1_y = this.nodes[edge0[1]][1];
		} else {
			p0_x = this.nodes[edge0[1]][0];
			p0_y = this.nodes[edge0[1]][1];
			p1_x = this.nodes[edge0[0]][0];
			p1_y = this.nodes[edge0[0]][1];
		}
		// p0 is the left-most node of edge0.
		if (this.nodes[edge1[0]][0] <= this.nodes[edge1[1]][0]) {
			p2_x = this.nodes[edge1[0]][0];
			p2_y = this.nodes[edge1[0]][1];
			p3_x = this.nodes[edge1[1]][0];
			p3_y = this.nodes[edge1[1]][1];
		} else {
			p2_x = this.nodes[edge1[1]][0];
			p2_y = this.nodes[edge1[1]][1];
			p3_x = this.nodes[edge1[0]][0];
			p3_y = this.nodes[edge1[0]][1];
		}
		// p2 is the left-most node of edge1.

		// Rule out intersection if one edge is completely to one side of the other.
		if (p1_x < p2_x) {
			// edge0 left of edge1.
			return false;
		}
		if (p0_x > p3_x) {
			// edge0 right of edge1.
			return false;
		}
		if (Math.max(p0_y, p1_y) < Math.min(p2_y, p3_y)) {
			// edge0 above edge1.
			return false;
		}
		if (Math.min(p0_y, p1_y) > Math.max(p2_y, p3_y)) {
			// edge0 below edge1.
			return false;
		}

	    s1_x = p1_x - p0_x;
		s1_y = p1_y - p0_y;
		s2_x = p3_x - p2_x;
		s2_y = p3_y - p2_y;

		denominator = -s2_x * s1_y + s1_x * s2_y;
		if (denominator == 0.0) {
			// Parallel. Could be collinear (ignoring this case).
			return false;
		}
		
		s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denominator;
		t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denominator;

		return s >= COLLISION_EPSILON && s <= (1.0 - COLLISION_EPSILON)
			&& t >= COLLISION_EPSILON && t <= (1 - COLLISION_EPSILON);
	}

	// Randomize node positions.
	function randomizeNodes() {
		for (i = 0; i < this.nodeCount; ++i) {
			this.nodes[i][0] = (0.1 + 0.8 * Random.randomFloat()) * X_RES;
			this.nodes[i][1] = (0.1 + 0.8 * Random.randomFloat()) * Y_RES;
		}
	}

	// Reset the game.
	function reset() {
		this.clickedNode = null;

		// Initialize nodes in a circle.
		this.nodes = [];
		for (i = 0; i < this.nodeCount; ++i) {
			theta = i * 2 * Math.PI / this.nodeCount;
			offset = Math.min(X_RES, Y_RES) / 2 - 20;
			this.nodes.add([X_RES / 2 + offset * Math.cos(theta), Y_RES / 2 + offset * Math.sin(theta)]);
		}

		// Generate all possible edges in random order.
		allEdges = [];
		for (i = 0; i < this.nodeCount - 1; ++i) {
			for (j = i + 1; j < this.nodeCount; ++j) {
				allEdges.add([i, j]);
			}
		}
		allEdges.shuffle();

		// Add random non-intersecting edges to the edge list.
		this.edges = [];
		for (candidateEdge : allEdges) {
			foundIntersection = false;
			for (existingEdge : this.edges) {
				if (this.intersect(candidateEdge, existingEdge)) {
					foundIntersection = true;
					break;
				}
			}
			if (!foundIntersection) {
				this.edges.add(candidateEdge);
			}
		}

		// Randomize node positions until there's an intersection.
		foundIntersection = false;
		do {
			this.randomizeNodes();
			for (i = 0; !foundIntersection && i < this.edges.length - 1; ++i) {
				for (j = i + 1; j < this.edges.length; ++j) {
					if (this.intersect(this.edges[i], this.edges[j])) {
						foundIntersection = true;
						break;
					}
				}
			}
		} while (!foundIntersection);

		// Relax nodes using antigravitation.
		this.antigravitate(300);

		this.levelText = this.font.render(this.nodes.length);

		this.levelTimer = MAX_TIME_PER_EDGE * this.edges.length;

		this.movesLeft = this.nodes.length;
	}

	// Pushes nodes away from each other and away from the edges.
	function antigravitate(iterations) {
		for (i = 0; i < iterations; ++i) {
			for (node : this.nodes) {
				wallForceFactor = 0.0005;
				vel =
					[ wallForceFactor * (X_RES / 2 - node[0])
					, wallForceFactor * (Y_RES / 2 - node[1])
					];
				for (otherNode : this.nodes) {
					if (otherNode != node) {
						dx = node[0] - otherNode[0];
						dy = node[1] - otherNode[1];
						d2 = dx ** 2.0 + dy ** 2.0;
						if (d2 != 0.0) {
							vel[0] += dx / d2;
							vel[1] += dy / d2;
						}
					}
				}
				velFactor = 15.0;
				node[0] += velFactor * vel[0];
				node[1] += velFactor * vel[1];

				if (node[0] < 0.0) {
					node[0] = 0.0;
				} else if (node[0] >= X_RES) {
					node[0] = X_RES - 1.0;
				}
				if (node[1] < 0.0) {
					node[1] = 0.0;
				} else if (node[1] >= Y_RES) {
					node[1] = Y_RES - 1.0;
				}
			}
		}
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressed(KeyboardKey.ESCAPE)) {
			this.switchScene(new TitleScene());
			return;
		}

		if (this.winTimer == 0) {
			--this.levelTimer;
		}

		if (this.winTimer > 0) {
			if (this.winTimer == 1) {
				++this.nodeCount;
				this.reset();
			}
			--this.winTimer;
		}

		mousePos = inputManager.getMousePosition();
		xMouse = 1.0 * mousePos[0];
		yMouse = 1.0 * mousePos[1];

		for (e : events) {
			switch (e.type) {
				case EventType.MOUSE_RELEASE:
					// Release clicked node, if any.
					if (this.clickedNode != null) {
						--this.movesLeft;
						this.clickedNode = null;
						if (this.solved && this.winTimer == 0) {
							this.winTimer = 100;
						}
					}
					break;
				case EventType.MOUSE_PRESS:
					// Find clicked node, if any.
					minDistance = 2 * NODE_RADIUS;
					for (i = 0; i < this.nodeCount; ++i) {
						distance = ((this.nodes[i][0] - xMouse) ** 2 + (this.nodes[i][1] - yMouse) ** 2) ** 0.5;
						if (distance <= NODE_RADIUS && (distance < minDistance)) {
							this.clickedNode = i;
							minDistance = distance;
						}
					}
					break;
				default:
					break;
			}
		}

		// Allow free manual antigravitation if game is not over.
		if (!this.gameOver && inputManager.isKeyPressed(KeyboardKey.SPACE)) {
			this.antigravitate(1);
		}

		// Clicked node follows mouse.
		if (this.clickedNode != null && !this.gameOver) {
			this.nodes[this.clickedNode][0] = xMouse;
			this.nodes[this.clickedNode][1] = yMouse;
		}

		// Find intersections and detect solutions.
		this.solved = true;
		this.intersectMap = [];
		for (i = 0; i < this.edges.length; ++i) {
			foundIntersection = false;
			for (otherEdge : this.edges) {
				if (otherEdge != this.edges[i] && this.intersect(this.edges[i], otherEdge)) {
					foundIntersection = true;
					this.solved = false;
					break;
				}
			}
			this.intersectMap.add(foundIntersection);
		}

		// Check for game over.
		switch (this.gameMode) {
			case GameMode.RELAX:
				break;
			case GameMode.TIMED:
				if (!this.solved && this.levelTimer == 0) {
					this.gameOver = true;
				}
				break;
			case GameMode.MOVES:
				if (!this.solved && this.movesLeft == 0) {
					this.gameOver = true;
				}
				break;
		}
	}

	function render() {
		bgColor = this.gameOver ? [212, 159, 159] : [212, 212, 212];

		Graphics2D.Draw.fill(bgColor[0], bgColor[1], bgColor[2]);

		// Draw edges.
		for (i = 0; i < this.edges.length; ++i) {
			// Draw edge outline.
			Graphics2D.Draw.line
				( this.nodes[this.edges[i][0]][0], this.nodes[this.edges[i][0]][1]
				, this.nodes[this.edges[i][1]][0], this.nodes[this.edges[i][1]][1]
				, EDGE_WIDTH + 2
				, 0, 0, 0
				);
			// Draw edge fill color.
			edgeColor = this.intersectMap[i]
				? [BAD_EDGE_R, BAD_EDGE_G, BAD_EDGE_B]
				: [GOOD_EDGE_R, GOOD_EDGE_G, GOOD_EDGE_B];
			Graphics2D.Draw.line
				( this.nodes[this.edges[i][0]][0], this.nodes[this.edges[i][0]][1]
				, this.nodes[this.edges[i][1]][0], this.nodes[this.edges[i][1]][1]
				, EDGE_WIDTH
				, edgeColor[0], edgeColor[1], edgeColor[2]
				);
		}

		// Draw nodes.
		for (i = 0; i < this.nodeCount; ++i) {
			if (this.solved) {
				nodeColor = (this.winTimer / 10) % 2 == 0
					? [GOOD_NODE_R, GOOD_NODE_G, GOOD_NODE_B]
					: [FLASH_NODE_R, FLASH_NODE_G, FLASH_NODE_B];
			} else {
				badNode = false;
				for (j = 0; j < this.edges.length; ++j) {
					if (this.edges[j][0] == i || this.edges[j][1] == i) {
						badNode = badNode || this.intersectMap[j];
					}
				}
				nodeColor = badNode
					? [BAD_NODE_R, BAD_NODE_G, BAD_NODE_B]
					: [GOOD_NODE_R, GOOD_NODE_G, GOOD_NODE_B];
			}
			Graphics2D.Draw.ellipse
				( this.nodes[i][0] - NODE_RADIUS, this.nodes[i][1] - NODE_RADIUS
				, 2 * NODE_RADIUS, 2 * NODE_RADIUS
				, 0, 0, 0
				);
			Graphics2D.Draw.ellipse
				( this.nodes[i][0] - NODE_RADIUS + NODE_BORDER, this.nodes[i][1] - NODE_RADIUS + NODE_BORDER
				, 2 * NODE_RADIUS - 2 * NODE_BORDER, 2 * NODE_RADIUS - 2 * NODE_BORDER
				, nodeColor[0], nodeColor[1], nodeColor[2]
				);
		}

		// Draw overlays.
		if (this.gameOver) {
			Graphics2D.Draw.rectangle
				( 0, 0
				, this.resetText.width, this.resetText.height
				, bgColor[0], bgColor[1], bgColor[2], 192
				);
			this.resetText.draw(0, 0);
		} else {
			switch (this.gameMode) {
				case GameMode.RELAX:
					// Nothing special to draw in this mode.
					break;
				case GameMode.TIMED:
					// Draw timer.
					Graphics2D.Draw.rectangle
						( 0, 0
						, X_RES * this.levelTimer / (MAX_TIME_PER_EDGE * this.edges.length), BAR_HEIGHT
						, 0, 0, 0, 128
						);
					break;
				case GameMode.MOVES:
					// Draw move counter.
					for (i = 0; i < this.movesLeft; ++i) {
						start = i * X_RES / this.nodes.length + 1;
						end = Math.min(X_RES - 1, (i + 1) * X_RES / this.nodes.length);
						Graphics2D.Draw.rectangle
							( start, 1
							, end - start, BAR_HEIGHT - 1
							, 0, 0, 0, 128
							);
					}
					break;
			}
		}

		// Draw current number of nodes.
		Graphics2D.Draw.rectangle
			( 0, Y_RES - this.levelText.height
			, this.levelText.width, this.levelText.height
			, bgColor[0], bgColor[1], bgColor[2], 192
			);
		this.levelText.draw(0, Y_RES - this.levelText.height);
	}
}
