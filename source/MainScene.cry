import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha2;

const X_RES = 640;
const Y_RES = 480;

const NODE_RADIUS = 10.0;
const NODE_BORDER = 2.0;

const EDGE_WIDTH = 3.5;

const BAR_HEIGHT = 20;

const MAX_TIME_PER_EDGE = 100;
const MAX_MOVES_PER_EDGE = 1;

const WIN_TIMER_LENGTH = 75;

const COLOR_SATURATION = 0.6;
const COLOR_VALUE = 0.9;

enum GameMode { CASUAL, TIMED, MOVES }

enum GameState
	{ GAME_OVER
	, WON
	, NEUTRAL
	, DRAG_SINGLE
	, SELECTING
	, SELECTED
	}

class MainScene : AbstractScene {
	field nodeCountText;
	field resetText = Font.font.setColor(0, 0, 0).render(" Press Esc to return to main menu.");

	// Game mode and state
	field gameMode;
	field state = GameState.NEUTRAL;

	field nodeCount;
	field nodes = [];
	field edges = [];
	field solved = false;
	field intersectMap;
	field winTimer = 0;

	// Timed mode
	field maxLevelTime;
	field levelTimer;

	// Move-counted mode
	field maxMoves;
	field movesLeft;

	field gameOver = false;

	// Draw order and color maps
	field nodeDrawOrder = [];
	field nodeColors = [];
	field edgeDrawOrder = [];
	field edgeColors = [];

	// Dragging
	field clickedNode;

	// Selecting/selected
	field selection = {};
	field selectionStart;
	field selectionEnd;

	field bgColor = [212, 212, 212];

	constructor(gameMode, nodeCount) : base() {
		this.gameMode = gameMode;
		this.nodeCount = nodeCount;
		this.nodeCountText = Font.font.setColor(0, 0, 0).render(" " + this.nodeCount + " ");

		// Initialize nodes in a circle.
		this.nodes = [];
		for (i = 0; i < this.nodeCount; ++i) {
			theta = i * 2 * Math.PI / this.nodeCount;
			offset = Math.min(X_RES, Y_RES) / 2 - 20;
			this.nodes.add([X_RES / 2 + offset * Math.cos(theta), Y_RES / 2 + offset * Math.sin(theta)]);
		}

		// Recursively connect all remaining nodes while retaining planarity.
		this.edges = [];
		this.planarConnect(0, this.nodes.length);

		// Randomize node positions until there's an intersection.
		foundIntersection = false;
		do {
			this.randomizeNodes();
			for (i = 0; !foundIntersection && i < this.edges.length - 1; ++i) {
				for (j = i + 1; j < this.edges.length; ++j) {
					if (this.intersect(this.edges[i], this.edges[j])) {
						foundIntersection = true;
						break;
					}
				}
			}
		} while (!foundIntersection);

		// Relax nodes to generate a good-looking initial layout.
		this.relax(300);

		this.maxLevelTime = MAX_TIME_PER_EDGE * this.edges.length;
		this.levelTimer = this.maxLevelTime;

		this.maxMoves = MAX_MOVES_PER_EDGE * this.edges.length;
		this.movesLeft = this.maxMoves;

		// Set draw orders and colors.
		for (i = 0; i < this.nodes.length; ++i) {
			this.nodeDrawOrder.add(i);
		}
		// Shuffle node draw order (and therefore color assignment) to avoid giving hints.
		this.nodeDrawOrder.shuffle();
		for (i = 0; i < this.nodes.length; ++i) {
			this.nodeColors.add(MainScene.hsvToRgb
				( this.nodeDrawOrder[i] * 360.0 / this.nodes.length
				, COLOR_SATURATION
				, COLOR_VALUE
				));
		}
		// Shuffle initial edge draw order, which also determines color.
		for (i = 0; i < this.edges.length; ++i) {
			this.edgeDrawOrder.add(i);
		}
		this.edgeDrawOrder.shuffle();
		for (i = 0; i < this.edges.length; ++i) {
			this.edgeColors.add(MainScene.hsvToRgb
				( this.edgeDrawOrder[i] * 360.0 / this.edges.length
				, COLOR_SATURATION
				, COLOR_VALUE
				));
		}
	}

	// Computes x mod y, where x and y are nonnegative floating-point numbers.
	static function fmod(x, y) {
		while (x > y) {
			x -= y;
		}
		return x;
	}

	// h in [0.0, 360.0)
	// s in [0.0, 1.0]
	// v in [0.0, 1.0]
	static function hsvToRgb(h, s, v) {
		c = v * s;
		x = c * (1.0 - Math.abs(MainScene.fmod(h / 60, 2.0) - 1.0));
		m = v - c;
		switch (floor(h) / 60) {
			case 0:
				rgbPrime = [c, x, 0];
				break;
			case 1:
				rgbPrime = [x, c, 0];
				break;
			case 2:
				rgbPrime = [0, c, x];
				break;
			case 3:
				rgbPrime = [0, x, c];
				break;
			case 4:
				rgbPrime = [x, 0, c];
				break;
			case 5:
				rgbPrime = [c, 0, x];
				break;
		}
		return
			[ Math.floor((rgbPrime[0] + m) * 255)
			, Math.floor((rgbPrime[1] + m) * 255)
			, Math.floor((rgbPrime[2] + m) * 255)
			];
	}

	// Checks for intersection between line segments.
	// Adapted from https://stackoverflow.com/a/1968345/3217185.
	function intersect(edge0, edge1) {
		// Edges that share a node do not intersect.
		if (edge0[0] == edge1[0] || edge0[0] == edge1[1] || edge0[1] == edge1[0] || edge0[1] == edge1[1]) {
			return false;
		}

		// Put left points first.
		if (this.nodes[edge0[0]][0] <= this.nodes[edge0[1]][0]) {
			p0_x = this.nodes[edge0[0]][0];
			p0_y = this.nodes[edge0[0]][1];
			p1_x = this.nodes[edge0[1]][0];
			p1_y = this.nodes[edge0[1]][1];
		} else {
			p0_x = this.nodes[edge0[1]][0];
			p0_y = this.nodes[edge0[1]][1];
			p1_x = this.nodes[edge0[0]][0];
			p1_y = this.nodes[edge0[0]][1];
		}
		// p0 is the left-most node of edge0.
		if (this.nodes[edge1[0]][0] <= this.nodes[edge1[1]][0]) {
			p2_x = this.nodes[edge1[0]][0];
			p2_y = this.nodes[edge1[0]][1];
			p3_x = this.nodes[edge1[1]][0];
			p3_y = this.nodes[edge1[1]][1];
		} else {
			p2_x = this.nodes[edge1[1]][0];
			p2_y = this.nodes[edge1[1]][1];
			p3_x = this.nodes[edge1[0]][0];
			p3_y = this.nodes[edge1[0]][1];
		}
		// p2 is the left-most node of edge1.

		// Rule out intersection if one edge is completely to one side of the other.
		if (p1_x < p2_x) {
			// edge0 left of edge1.
			return false;
		}
		if (p0_x > p3_x) {
			// edge0 right of edge1.
			return false;
		}
		if (Math.max(p0_y, p1_y) < Math.min(p2_y, p3_y)) {
			// edge0 above edge1.
			return false;
		}
		if (Math.min(p0_y, p1_y) > Math.max(p2_y, p3_y)) {
			// edge0 below edge1.
			return false;
		}

	    s1_x = p1_x - p0_x;
		s1_y = p1_y - p0_y;
		s2_x = p3_x - p2_x;
		s2_y = p3_y - p2_y;

		denominator = -s2_x * s1_y + s1_x * s2_y;
		if (denominator == 0.0) {
			// Parallel. Could be collinear (ignoring this case).
			return false;
		}
		
		s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denominator;
		t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denominator;

		return s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0;
	}

	// Randomize node positions.
	function randomizeNodes() {
		for (i = 0; i < this.nodeCount; ++i) {
			this.nodes[i][0] = (0.1 + 0.8 * Random.randomFloat()) * X_RES;
			this.nodes[i][1] = (0.1 + 0.8 * Random.randomFloat()) * Y_RES;
		}
	}

	// Connects all the nodes from start to start + distance (modularly) until no more straight-line connections can be made without intersection.
	function planarConnect(start, distance, depth = 0) {
		end = (start + distance) % this.nodes.length;
		if (distance <= 2) {
			for (i = 0; i < distance; ++i) {
				this.edges.add([start + i, (start + i + 1) % this.nodes.length]);
			}
			return;
		}
		if (Random.randomInt(0, 2) == 0) {
			// Draw from start.
			i = Random.randomInt(start + 2, start + distance);
			this.edges.add([start, i]);
			if (start != end) {
				this.edges.add([i, end]);
			}
		} else {
			// Draw to end.
			i = Random.randomInt(start + 1, start + distance - 1);
			this.edges.add([i, end]);
			if (start != end) {
				this.edges.add([start, i]);
			}
		}
		this.planarConnect(start, i - start, depth + 1);
		this.planarConnect(i, start + distance - i, depth + 1);
	}

	// Pushes nodes away from each other and away from the edges.
	function relax(iterations) {
		for (i = 0; i < iterations; ++i) {
			for (node : this.nodes) {
				wallForceFactor = 0.0005;
				vel =
					[ wallForceFactor * (X_RES / 2 - node[0])
					, wallForceFactor * (Y_RES / 2 - node[1])
					];
				for (otherNode : this.nodes) {
					if (otherNode != node) {
						dx = node[0] - otherNode[0];
						dy = node[1] - otherNode[1];
						d2 = dx ** 2.0 + dy ** 2.0;
						if (d2 != 0.0) {
							vel[0] += dx / d2;
							vel[1] += dy / d2;
						}
					}
				}
				velFactor = 15.0;
				node[0] += velFactor * vel[0];
				node[1] += velFactor * vel[1];

				if (node[0] < 0.0) {
					node[0] = 0.0;
				} else if (node[0] >= X_RES) {
					node[0] = X_RES - 1.0;
				}
				if (node[1] < 0.0) {
					node[1] = 0.0;
				} else if (node[1] >= Y_RES) {
					node[1] = Y_RES - 1.0;
				}
			}
		}
	}

	// Moves the node with the given index and its attached edges to the front.
	function moveToFront(index) {
		// Bubble up the target node.
		for (i = 0; i < this.nodeDrawOrder.length - 1; ++i) {
			if (this.nodeDrawOrder[i] == index) {
				t = this.nodeDrawOrder[i + 1];
				this.nodeDrawOrder[i] = t;
				this.nodeDrawOrder[i + 1] = index;
			}
		}
		// Stably partition the edges, with attached edges in front.
		edgeDrawOrderPartition = [[], []];
		edgeColorsPartition = [[], []];
		for (i = 0; i < this.edgeDrawOrder.length; ++i) {
			edge = this.edges[this.edgeDrawOrder[i]];
			if (edge[0] == index || edge[1] == index) {
				edgeDrawOrderPartition[1].add(this.edgeDrawOrder[i]);
				edgeColorsPartition[1].add(this.edgeColors[i]);
			} else {
				edgeDrawOrderPartition[0].add(this.edgeDrawOrder[i]);
				edgeColorsPartition[0].add(this.edgeColors[i]);
			}
		}
		this.edgeDrawOrder = edgeDrawOrderPartition[0];
		this.edgeDrawOrder.concat(edgeDrawOrderPartition[1]);
		this.edgeColors = edgeColorsPartition[0];
		this.edgeColors.concat(edgeColorsPartition[1]);
	}

	function endGame() {
		this.gameOver = true;
		this.bgColor = [212, 159, 159];
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressed(KeyboardKey.ESCAPE)) {
			this.switchScene(new TitleScene());
			return;
		}

		if (this.winTimer == 0) {
			--this.levelTimer;
		}

		if (this.winTimer > 0) {
			--this.winTimer;
			if (this.winTimer == 0) {
				this.switchScene(new LoadingScene(this.gameMode, this.nodeCount + 1));
			}
			return;
		}

		mousePos = inputManager.getMousePosition();
		xMouse = 1.0 * mousePos[0];
		yMouse = 1.0 * mousePos[1];

		if (!this.gameOver) {
			for (e : events) {
				switch (e.type) {
					case EventType.MOUSE_RELEASE:
						switch (this.state) {
							case GameState.NEUTRAL:
								break;
							case GameState.DRAG_SINGLE:
								// Release clicked node.
								--this.movesLeft;
								this.clickedNode = null;
								if (this.solved && this.winTimer == 0) {
									this.winTimer = WIN_TIMER_LENGTH;
								}
								this.state = GameState.NEUTRAL;
								break;
							case GameState.SELECTING:
								// Create selection.
								this.state = GameState.SELECTED;
								xMin = Math.min(this.selectionStart[0], this.selectionEnd[0]);
								xMax = Math.max(this.selectionStart[0], this.selectionEnd[0]);
								yMin = Math.min(this.selectionStart[1], this.selectionEnd[1]);
								yMax = Math.max(this.selectionStart[1], this.selectionEnd[1]);
								this.selection = {};
								for (i = 0; i < this.nodes.length; ++i) {
									node = this.nodes[i];
									if (xMin <= node[0] && node[0] <= xMax && yMin <= node[1] && node[1] <= yMax) {
										this.selection[i] = null;
									}
								}
								this.state = this.selection.length == 0 ? GameState.NEUTRAL : GameState.SELECTED;
								break;
							case GameState.SELECTED:
								// Unselect.
								this.state = GameState.NEUTRAL;
								break;
						}
						break;
					case EventType.MOUSE_PRESS:
						switch (this.state) {
							case GameState.NEUTRAL:
								if (inputManager.isShiftPressed()) {
									// Group selection.
									this.state = GameState.SELECTING;
									this.selectionStart = mousePos.clone();
								} else {
									// Single-node selection.
									this.clickedNode = null;
									minDistance = 2 * NODE_RADIUS;
									for (i = 0; i < this.nodes.length; ++i) {
										distance = ((this.nodes[i][0] - xMouse) ** 2 + (this.nodes[i][1] - yMouse) ** 2) ** 0.5;
										if (distance <= NODE_RADIUS && (distance < minDistance)) {
											this.clickedNode = i;
											minDistance = distance;
										}
									}
									if (this.clickedNode != null) {
										// Move clicked node and attached edges to the front.
										this.moveToFront(this.clickedNode);
										this.state = GameState.DRAG_SINGLE;
									}
								}
								break;
							case GameState.DRAG_SINGLE:
								break;
							case GameState.SELECTING:
								break;
							case GameState.SELECTED:
								// Check for drag.
								break;
						}
						break;
					default:
						break;
				}
			}
			if (this.state == GameState.SELECTING) {
				this.selectionEnd = mousePos.clone();
			}
		}

		// Allow free manual relaxation if game is not over.
		if (!this.gameOver && this.winTimer == 0 && inputManager.isKeyPressed(KeyboardKey.SPACE)) {
			this.relax(1);
		}

		// Clicked node follows mouse.
		if (this.state == GameState.DRAG_SINGLE && !this.gameOver) {
			this.nodes[this.clickedNode][0] = xMouse;
			this.nodes[this.clickedNode][1] = yMouse;
		}

		// Find intersections and detect solutions.
		this.solved = true;
		this.intersectMap = [];
		for (i = 0; i < this.edges.length; ++i) {
			foundIntersection = false;
			for (otherEdge : this.edges) {
				if (otherEdge != this.edges[i] && this.intersect(this.edges[i], otherEdge)) {
					foundIntersection = true;
					this.solved = false;
					break;
				}
			}
			this.intersectMap.add(foundIntersection);
		}

		// Check for game over.
		switch (this.gameMode) {
			case GameMode.CASUAL:
				break;
			case GameMode.TIMED:
				if (!this.solved && this.levelTimer == 0) {
					this.endGame();
				}
				break;
			case GameMode.MOVES:
				if (!this.solved && this.movesLeft == 0) {
					this.endGame();
				}
				break;
		}
	}

	function drawEdges() {
		for (i = 0; i < this.edgeDrawOrder.length; ++i) {
			j = this.edgeDrawOrder[i];
			alpha = this.solved && this.winTimer > 0
				? 64 * this.winTimer / WIN_TIMER_LENGTH
				: this.intersectMap[j] ? 255 : 64;
			x1 = this.nodes[this.edges[j][0]][0];
			y1 = this.nodes[this.edges[j][0]][1];
			x2 = this.nodes[this.edges[j][1]][0];
			y2 = this.nodes[this.edges[j][1]][1];
			// Draw edge outline.
			Graphics2D.Draw.line(x1, y1, x2, y2, EDGE_WIDTH + 2, 0, 0, 0, alpha);
			// Draw edge fill.
			edgeColor = this.edgeColors[i];
			Graphics2D.Draw.line(x1, y1, x2, y2, EDGE_WIDTH, edgeColor[0], edgeColor[1], edgeColor[2], alpha);
		}
	}

	function drawNodes() {
		for (i = 0; i < this.nodeDrawOrder.length; ++i) {
			j = this.nodeDrawOrder[i];
			nodeColor = this.selection.contains(j) ? [255, 255, 255] : this.nodeColors[j];
			if (this.solved && this.winTimer > 0) {
				alpha = 64 * this.winTimer / WIN_TIMER_LENGTH;
			} else {
				badNode = false;
				for (k = 0; k < this.edges.length; ++k) {
					if (this.edges[k][0] == j || this.edges[k][1] == j) {
						badNode = badNode || this.intersectMap[k];
					}
				}
				alpha = badNode ? 255 : 64;
			}
			// Draw node outline.
			Graphics2D.Draw.ellipse
				( this.nodes[j][0] - NODE_RADIUS, this.nodes[j][1] - NODE_RADIUS
				, 2 * NODE_RADIUS, 2 * NODE_RADIUS
				, 0, 0, 0, alpha
				);
			// Draw node fill.
			Graphics2D.Draw.ellipse
				( this.nodes[j][0] - NODE_RADIUS + NODE_BORDER, this.nodes[j][1] - NODE_RADIUS + NODE_BORDER
				, 2 * NODE_RADIUS - 2 * NODE_BORDER, 2 * NODE_RADIUS - 2 * NODE_BORDER
				, nodeColor[0], nodeColor[1], nodeColor[2], alpha
				);
		}
	}

	function drawOverlay() {
		if (this.gameOver) {
			Graphics2D.Draw.rectangle
				( 0, 0
				, this.resetText.width, this.resetText.height
				, this.bgColor[0], this.bgColor[1], this.bgColor[2], 192
				);
			this.resetText.draw(0, 0);
		} else {
			switch (this.gameMode) {
				case GameMode.CASUAL:
					// Nothing special to draw in this mode.
					break;
				case GameMode.TIMED:
					// Draw timer.
					alpha = this.solved && this.winTimer > 0 ? 64 * this.winTimer / WIN_TIMER_LENGTH : 64;
					if (this.levelTimer != null) {
						Graphics2D.Draw.rectangle
							( 0, 0
							, X_RES * this.levelTimer / this.maxLevelTime, BAR_HEIGHT
							, 0, 0, 0, alpha
							);
					}
					break;
				case GameMode.MOVES:
					// Draw move counter.
					alpha = this.solved && this.winTimer > 0 ? 64 * this.winTimer / WIN_TIMER_LENGTH : 64;
					if (this.movesLeft != null) {
						for (i = 0; i < this.movesLeft; ++i) {
							start = i * X_RES / this.maxMoves + 1;
							end = Math.min(X_RES - 1, (i + 1) * X_RES / this.maxMoves);
							Graphics2D.Draw.rectangle
								( start, 1
								, end - start, BAR_HEIGHT - 1
								, 0, 0, 0, alpha
								);
						}
					}
					break;
			}
		}

		// Draw node count.
		Graphics2D.Draw.rectangle
			( 0, Y_RES - this.nodeCountText.height
			, this.nodeCountText.width, this.nodeCountText.height
			, this.bgColor[0], this.bgColor[1], this.bgColor[2], 192
			);
		this.nodeCountText.draw(0, Y_RES - this.nodeCountText.height);
	}

	function render() {
		Graphics2D.Draw.fill(this.bgColor[0], this.bgColor[1], this.bgColor[2]);
		this.drawEdges();
		this.drawNodes();
		// Draw selection box.
		if (this.state == GameState.SELECTING) {
			x = Math.min(this.selectionStart[0], this.selectionEnd[0]);
			y = Math.min(this.selectionStart[1], this.selectionEnd[1]);
			width = Math.abs(this.selectionEnd[0] - this.selectionStart[0]);
			height = Math.abs(this.selectionEnd[1] - this.selectionStart[1]);
			Graphics2D.Draw.rectangle(x, y, width, height, 255, 255, 255, 128);
			Graphics2D.Draw.line(x, y, x + width, y, 1, 0, 0, 0);
			Graphics2D.Draw.line(x, y, x, y + height, 1, 0, 0, 0);
			Graphics2D.Draw.line(x + width, y, x + width, y + height, 1, 0, 0, 0);
			Graphics2D.Draw.line(x, y + height, x + width, y + height, 1, 0, 0, 0);
		}
		this.drawOverlay();
	}
}
